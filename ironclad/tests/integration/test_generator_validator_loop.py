#!/usr/bin/env python3
"""
Integration tests for Generator → Validator loop.

These tests verify that UIs generated by Ironclad are validatable by Ironclad.
This enforces the core system invariant: generate() output must be validatable.

Tests use real filesystem operations via tmp_path.
"""

import pytest
import os
import sys
from pathlib import Path

# Add src to path
src_dir = Path(__file__).parent.parent.parent / "src"
sys.path.insert(0, str(src_dir))

from ironclad_ai_guardrails.ui_generator import generate_ui_from_module_spec
from ironclad_ai_guardrails.ui_validator import UIValidator, ValidationStatus


class TestGeneratorValidatorLoop:
    """Integration tests for the complete generator → validator loop."""

    @pytest.fixture
    def module_spec(self):
        """Provide a valid ModuleSpec for testing."""
        return {
            "module_name": "test_module",
            "main_logic_description": "Test module for integration testing",
            "functions": [
                {
                    "name": "process_data",
                    "signature": "def process_data(input: str, count: int, verbose: bool = False) -> str:",
                    "description": "Process input data with options"
                },
                {
                    "name": "main",
                    "signature": "def main() -> None:",
                    "description": "Main entry point"
                }
            ]
        }

    def test_generate_and_validate_web_ui(self, tmp_path, module_spec):
        """Test web UI generation produces validatable output."""
        output_dir = tmp_path / "web_ui"
        
        # Generate UI
        generate_ui_from_module_spec(module_spec, ui_type="web", output_dir=str(output_dir))
        
        # Verify files were created
        assert output_dir.exists(), "Output directory should be created"
        
        # Validate generated UI
        validator = UIValidator(str(output_dir), "web")
        result = validator.validate_all()
        
        # Assertions
        assert result is not None, "Validation result should exist"
        assert result.status in [ValidationStatus.PASSED, ValidationStatus.WARNING], \
            f"Status should be PASSED or WARNING, got {result.status}"
        assert result.metadata["ui_type"] == "web", "UI type should be web"
        assert isinstance(result.issues, list), "Issues should be a list"

    def test_generate_and_validate_cli_gui(self, tmp_path, module_spec):
        """Test CLI GUI generation produces validatable output."""
        output_dir = tmp_path / "cli_gui_ui"
        
        # Generate UI
        generate_ui_from_module_spec(module_spec, ui_type="cli_gui", output_dir=str(output_dir))
        
        # Verify files were created
        assert output_dir.exists(), "Output directory should be created"
        
        # Validate generated UI
        validator = UIValidator(str(output_dir), "cli_gui")
        result = validator.validate_all()
        
        # Assertions
        assert result is not None, "Validation result should exist"
        assert result.status in [ValidationStatus.PASSED, ValidationStatus.WARNING], \
            f"Status should be PASSED or WARNING, got {result.status}"
        assert result.metadata["ui_type"] == "cli_gui", "UI type should be cli_gui"
        assert isinstance(result.issues, list), "Issues should be a list"

    def test_generate_and_validate_desktop_ui(self, tmp_path, module_spec):
        """Test desktop UI generation produces validatable output."""
        output_dir = tmp_path / "desktop_ui"
        
        # Generate UI
        generate_ui_from_module_spec(module_spec, ui_type="desktop", output_dir=str(output_dir))
        
        # Verify files were created
        assert output_dir.exists(), "Output directory should be created"
        
        # Validate generated UI
        validator = UIValidator(str(output_dir), "desktop")
        result = validator.validate_all()
        
        # Assertions
        assert result is not None, "Validation result should exist"
        assert result.status in [ValidationStatus.PASSED, ValidationStatus.WARNING], \
            f"Status should be PASSED or WARNING, got {result.status}"
        assert result.metadata["ui_type"] == "desktop", "UI type should be desktop"
        assert isinstance(result.issues, list), "Issues should be a list"

    def test_generate_and_validate_api_docs(self, tmp_path, module_spec):
        """Test API docs generation produces validatable output."""
        output_dir = tmp_path / "api_docs_ui"
        
        # Generate UI
        generate_ui_from_module_spec(module_spec, ui_type="api_docs", output_dir=str(output_dir))
        
        # Verify files were created
        assert output_dir.exists(), "Output directory should be created"
        
        # Validate generated UI
        validator = UIValidator(str(output_dir), "api_docs")
        result = validator.validate_all()
        
        # Assertions
        assert result is not None, "Validation result should exist"
        assert result.status in [ValidationStatus.PASSED, ValidationStatus.WARNING], \
            f"Status should be PASSED or WARNING, got {result.status}"
        assert result.metadata["ui_type"] == "api_docs", "UI type should be api_docs"
        assert isinstance(result.issues, list), "Issues should be a list"

    def test_generate_and_validate_cli_tui(self, tmp_path, module_spec):
        """Test CLI TUI generation produces validatable output."""
        output_dir = tmp_path / "cli_tui_ui"
        
        # Generate UI
        generate_ui_from_module_spec(module_spec, ui_type="cli_tui", output_dir=str(output_dir))
        
        # Verify files were created
        assert output_dir.exists(), "Output directory should be created"
        
        # Validate generated UI
        validator = UIValidator(str(output_dir), "cli_tui")
        result = validator.validate_all()
        
        # Assertions
        assert result is not None, "Validation result should exist"
        assert result.status in [ValidationStatus.PASSED, ValidationStatus.WARNING], \
            f"Status should be PASSED or WARNING, got {result.status}"
        assert result.metadata["ui_type"] == "cli_tui", "UI type should be cli_tui"
        assert isinstance(result.issues, list), "Issues should be a list"

    def test_loop_with_complex_module_spec(self, tmp_path):
        """Test generator → validator loop with complex module specification."""
        complex_spec = {
            "module_name": "data_processor",
            "main_logic_description": "Complex data processing module with multiple functions",
            "functions": [
                {
                    "name": "load_data",
                    "signature": "def load_data(file_path: str, encoding: str = 'utf-8') -> List[Dict]:",
                    "description": "Load data from file"
                },
                {
                    "name": "transform",
                    "signature": "def transform(data: List[Dict], normalize: bool = True) -> List[Dict]:",
                    "description": "Transform data structure"
                },
                {
                    "name": "export",
                    "signature": "def export(data: List[Dict], output_path: str, format: str = 'json') -> None:",
                    "description": "Export processed data"
                },
                {
                    "name": "main",
                    "signature": "def main(input_path: str, output_path: str) -> None:",
                    "description": "Main processing pipeline"
                }
            ]
        }

        # Test for each UI type
        for ui_type in ["web", "cli_gui", "desktop", "api_docs", "cli_tui"]:
            output_dir = tmp_path / f"complex_{ui_type}"
            
            # Generate
            generate_ui_from_module_spec(complex_spec, ui_type=ui_type, output_dir=str(output_dir))
            assert output_dir.exists(), f"Output directory should exist for {ui_type}"
            
            # Validate
            validator = UIValidator(str(output_dir), ui_type)
            result = validator.validate_all()
            
            # Assertions
            assert result is not None, f"Validation result should exist for {ui_type}"
            assert result.status in [ValidationStatus.PASSED, ValidationStatus.WARNING], \
                f"Status should be PASSED or WARNING for {ui_type}, got {result.status}"
            assert result.metadata["ui_type"] == ui_type, \
                f"UI type should be {ui_type}, got {result.metadata['ui_type']}"
            assert isinstance(result.issues, list), f"Issues should be a list for {ui_type}"

    def test_loop_enforces_system_invariant(self, tmp_path, module_spec):
        """Test that the loop enforces the core system invariant."""
        # The invariant: generated UIs must always be validatable
        
        ui_types = ["web", "cli_gui", "desktop", "api_docs", "cli_tui"]
        
        for ui_type in ui_types:
            output_dir = tmp_path / f"invariant_test_{ui_type}"
            
            # Generate
            generate_ui_from_module_spec(module_spec, ui_type=ui_type, output_dir=str(output_dir))
            
            # Validate - this should always succeed (PASS or WARN, not FAIL)
            validator = UIValidator(str(output_dir), ui_type)
            result = validator.validate_all()
            
            # The invariant: generated UIs should not have CRITICAL or ERROR issues
            assert result.status != ValidationStatus.FAILED, \
                f"System invariant violated: {ui_type} UI failed validation"
            assert result.status in [ValidationStatus.PASSED, ValidationStatus.WARNING], \
                f"Generated {ui_type} UI should validate successfully"

    def test_loop_with_empty_module_spec(self, tmp_path):
        """Test generator → validator loop with minimal module specification."""
        minimal_spec = {
            "module_name": "minimal",
            "main_logic_description": "Minimal module",
            "functions": [
                {
                    "name": "main",
                    "signature": "def main() -> None:",
                    "description": "Main function"
                }
            ]
        }

        output_dir = tmp_path / "minimal_web_ui"
        
        # Generate
        generate_ui_from_module_spec(minimal_spec, ui_type="web", output_dir=str(output_dir))
        
        # Validate
        validator = UIValidator(str(output_dir), "web")
        result = validator.validate_all()
        
        # Assertions - even minimal specs should generate validatable UIs
        assert result is not None, "Validation result should exist"
        assert result.status in [ValidationStatus.PASSED, ValidationStatus.WARNING], \
            "Minimal UI should be validatable"
        assert result.metadata["ui_type"] == "web", "UI type should be web"
        assert isinstance(result.issues, list), "Issues should be a list"

    def test_validator_metadata_includes_ui_type(self, tmp_path, module_spec):
        """Test that validator metadata correctly identifies UI type."""
        ui_types = ["web", "cli_gui", "desktop", "api_docs", "cli_tui"]
        
        for ui_type in ui_types:
            output_dir = tmp_path / f"metadata_test_{ui_type}"
            
            # Generate
            generate_ui_from_module_spec(module_spec, ui_type=ui_type, output_dir=str(output_dir))
            
            # Validate
            validator = UIValidator(str(output_dir), ui_type)
            result = validator.validate_all()
            
            # Metadata should include correct UI type
            assert "ui_type" in result.metadata, "Metadata should include ui_type"
            assert result.metadata["ui_type"] == ui_type, \
                f"Metadata ui_type should be {ui_type}, got {result.metadata['ui_type']}"

    def test_validator_issues_structure(self, tmp_path, module_spec):
        """Test that validator returns properly structured issues list."""
        output_dir = tmp_path / "issues_test_web"
        
        # Generate
        generate_ui_from_module_spec(module_spec, ui_type="web", output_dir=str(output_dir))
        
        # Validate
        validator = UIValidator(str(output_dir), "web")
        result = validator.validate_all()
        
        # Issues should be a list (empty or non-empty)
        assert isinstance(result.issues, list), "Issues should be a list"
        
        # If issues exist, they should have proper structure
        for issue in result.issues:
            assert hasattr(issue, "level"), "Issue should have level attribute"
            assert hasattr(issue, "message"), "Issue should have message attribute"
